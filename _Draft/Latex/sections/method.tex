\chapter{研究方法}
\label{cha:methodology}

本論文中，我們仍保持 Joris Dormans~\cite{dormans2010adventures}~\cite{dormans2012engineering} 與 Antonios Liapis~\cite{liapis2013generating} 為求遊戲設計過程抽象化與高階化的訴求。將「Mission/Space 框架」與「Multi-segment 演化」兩種關卡生成方法結合並予以改良，保留了前者追求的遊戲進程之順序性，後者帶來穩定且多樣化的遊戲內容，希冀藉此提升整體遊戲體驗、相輔相成。

圖~\ref{fig:system-framework} 為系統的整體流程圖。遊戲設計師能夠透過宏觀的觀點來構築遊戲體驗流，將遊玩特徵拆分成多項規則，利用生成語法及改寫系統生成出任務圖，圖~\ref{fig:system-framework}-a。依照任務圖中對應的終端節點 (terminal nodes) 轉換為事先建構完成的房間容器，並得到尚未包含遊戲物件的遊戲地圖，圖~\ref{fig:system-framework}-b 至 c。接下來，針對動作冒險遊戲我們提出了數項評估遊戲性的適應性函數，藉由基因演算法的演化流程，令各房間遵守適應性函數的限制，以得到符合訴求的最適解，圖~\ref{fig:system-framework}-c 至 e。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/系統框架.png}
    \caption{本論文提出系統之流程圖} 
    \label{fig:system-framework}
  \end{center}
\end{figure}

\section{任務語法}
\label{sec:method-missiongrammars}

我們基於 Joris Dormans 提出之 Mission Grammars 概念，進行實作與改良出 Dungeon Generator 工具，這項工具佈署在 Unity Engine 上。遊戲設計師能夠藉由 Dungeon Generator 工具進行任務語法的建置，並執行改寫系統以輸出任務圖，進一步利用任務圖產出遊戲關卡空間。

在任務語法的設計階段，我們參考~\ref{ssec:relatedworks-gameswithprocedural-isaac} 小節所提及之遊戲 \textbf{The binding of Isaac} 的關卡地圖，分析其遊戲進程結構，構想期望的任務圖並將觀察其遊玩特徵，接著拆分成任務語法規則使用改寫規則產生出近似結構的任務圖。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/Dungeon_Generator_工具.png}
    \caption{Dungeon Generator 工具} 
    \label{fig:dungeon-generator}
  \end{center}
\end{figure}

\subsection{建立任務符號表}
\label{ssec:method-missiongrammars-alphabet}

在本小節，會以 \textbf{The binding of Isaac} 遊戲關卡作為範例，解析其遊玩特徵並作為任務語法的節點。
% ；以及說明在 Dungeon Generator 工具中如何操作符號表，進行新增、修改與刪除節點等動作。

\subsubsection{解析遊玩特徵}
\label{sssec:method-missiongrammars-alphabet-extractpatterns}

在任務語法中，任務節點可表示表示為一項事件、挑戰、動作或遊戲物件等。藉由觀察 \textbf{The binding of Isaac} 的遊戲關卡後，能夠發現房間擁有固定類型，並且對於房間之間進行程序化的排列組合。然而固定的房間類型便是我們所尋找的節點種類，藉此歸納出「入口 (entrance)、出口 (goal)、魔王房 (boss)、一般房 (normal)」外，以及一定機率會出現的稀有特殊房間「秘密房 (secret)、商店 (shop)、寶藏房 (treasure)」。這些稀有房間帶來了一些制式的事件，在進入秘密房前必須使用炸彈將牆壁給破壞的事件 (bomb)，以及從秘密房取得的鑰匙能夠進行解鎖 (lock)，開通進入商店或寶藏房的權限。而前述的遊玩特徵將轉化為終端節點 (terminal nodes) 的圓形符號形式，表示較為詳盡的任務內容；另外一種為方形符號的非終端節點 (non-terminal nodes)，相較於終端節點更為高階、抽象化，在此我們定義出起始節點 (Start)、一般房 (Normal) 與特殊房 (Special) 等，其應用方式將在下一小節~\ref{ssec:method-missiongrammars-rules} 中介紹。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/missiongrammars-alphabet.png}
    \caption{利用遊玩特徵建立任務符號表之範例} 
    \label{fig:missiongrammars-alphabet}
  \end{center}
\end{figure}

% \subsubsection{任務符號表使用說明}
% \label{sssec:method-missiongrammars-alphabet-manual}

% content here.

% \begin{figure}[ht]
%   \begin{center}
%     \includegraphics[width=1.0\textwidth]{figures/missiongrammars-alphabet-manual.png}
%     \caption{利用 Dungeon Generator 建立符號表} 
%     \label{fig:missiongrammars-alphabet-manual}
%   \end{center}
% \end{figure}

\subsection{建立任務規則}
\label{ssec:method-missiongrammars-rules}

任務規則分為左側規則及右側規則，二者皆為圖形語法 (Graph Grammars) 所構成，左側規則為被取代方、右側規則為取代方，在任務圖中若有子圖符合任務規則的左側，將會依照流程進行替換改寫動作至規則右側。為了方便管理與分類不同性質的規則，在 Dungeon Generator 中定義一任務語法包含了多個任務規則群組，各自群組底下有複數個任務改寫規則。規則被賦予使用數量上的條件限制，分為使用上限次數與下限次數，上限次數表示完整的改寫系統運行過程，最多能夠套用該規則的次數上限，多為了因應部分遊玩特徵的獨特性或稀有性；反之，下限次數表示套用該規則的次數下限，此外能利用於改寫系統的疊代結果已趨於穩定，任務圖無剩餘任何非終端節點的情形下，作為持續進行改寫系統的強制約束條件。

\subsubsection{線性任務規則}
\label{sssec:method-missiongrammars-rules-linearrules}

玩家在進行遊戲時，會有一條的主要任務流程、劇情安排，圖~\ref{fig:missiongrammars-rules-linear-example} 設計了三道任務規則，分別為主線任務、魔王房與一般房。主線任務規則中，系統會從預設起始節點 (starting node) 開始進行改寫，並轉換為由終端節點起點 (entrance) 與終點 (goal) 所構成的線性任務，其中兩節點之間由多個非終端節點的一般房 (Normal)，而非終端節點的一般房會倚賴其它規則進行後續替換。魔王房規則中，規則左側中定義了必須為非終端節點的一般房 (Normal) 與終點 (goal) 相連，並改寫該一般房為魔王房 (boss)。一般房規則中，會將任務圖中的剩餘非終端節點的一般房 (Normal) 替換為終端節點的一般房 (normal)。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/missiongrammars-rules-linear-example.png}
    \caption{線性任務規則範例，建立主線任務}
    \label{fig:missiongrammars-rules-linear-example}
  \end{center}
\end{figure}

結合後續第~\ref{sec:method-spacepieces} 章節 - 空間建構，並以主線任務相關規則生成任務圖後，便可將關卡輸出近似於圖~\ref{fig:missiongrammars-rules-linear-preview} 的空間。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/missiongrammars-rules-linear-preview.png}
    \caption{建立主線任務的預期任務圖與空間預覽}
    \label{fig:missiongrammars-rules-linear-preview}
  \end{center}
\end{figure}

\subsubsection{非線性任務規則}
\label{sssec:method-missiongrammars-rules-nonlinearrules}

圖~\ref{fig:missiongrammars-rules-nonlinear-example1}，為求遊戲內容的多樣性，非終端節點的一般房 (Normal) 將有機會轉換為其它種類的遊玩特徵，圖~\ref{fig:missiongrammars-rules-nonlinear-example1} 定義了特殊房間的配置工作。配置特殊房規則中，非終端節點的一般房 (Normal) 與任一節點 (? - Any) 相連的圖形語法，會被轉換為規則右側的非線性任務圖形語法，當中的秘密區域 (secret) 能夠獲取鑰匙，並有兩道需要由炸彈才能夠突破的牆壁 (bomb) 與其它區域阻隔，此外延伸出特殊房 (Special) 需另外定義規則使之轉換為終端節點。由於這項規則屬於較為稀少的任務類型，在套用數量上將有所限制。在商店規則與寶藏房規則中，規則左側中定義了非終端節點的特殊房 (Special) 能夠被改寫為鎖 (lock) 與商店 (shop) 或寶藏房 (treasure) 相連的遊玩特徵。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/missiongrammars-rules-nonlinear-example1.png}
    \caption{非線性任務規則範例，設置特殊房}
    \label{fig:missiongrammars-rules-nonlinear-example1}
  \end{center}
\end{figure}

圖~\ref{fig:missiongrammars-rules-nonlinear-example2}，為使玩家進行遊戲能夠提前遇見鎖 (lock)，當下卻找不到鑰匙的遊玩特徵，進而思考、尋找開鎖的方式，便利用鎖向前規則將鎖的分支一同往前挪動。房間攤平規則，為避免單一房間與過多的房間連通，將部分房間進行移前推挪。
 
\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/missiongrammars-rules-nonlinear-example2.png}
    \caption{非線性任務規則範例，鎖的提前出現與房間攤平}
    \label{fig:missiongrammars-rules-nonlinear-example2}
  \end{center}
\end{figure}

% \subsubsection{重複循環型任務規則}
% \label{sssec:method-missiongrammars-rules-cyclic}

% 遊戲設計師能夠依照需求定義出無窮的疊代規則，舉例來說，

\subsubsection{排除非法規則}
\label{sssec:method-missiongrammars-rules-illegals}

設計規則時，Dungeon Generator 將排除不合法的九項設計原則，非法的設計特徵會導致改寫系統出現錯誤，例如：改寫系統陷入無限循環或任務圖破碎化。在表~\ref{tbl:illegal-mission-rules} 所列舉之條件於某些情況中，可能彼此會同時符合多項非法條件，系統將依照判斷順序擇一輸出。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/under_construction.png}
    \caption{於 Dungeon Generator 工具中，若規則為非法狀態將不予生效}
    \label{fig:missiongrammars-illegal-rules}
  \end{center}
\end{figure}

\begin{table}[h!]
  \centering
  \caption{非法的任務規則定義}
  \label{tbl:illegal-mission-rules}
  \bigskip
  \begin{tabular}{| p{4cm} | p{10cm} |}
    \hline
    \multicolumn{1}{ |c| }{非法規則之標籤} & \multicolumn{1}{ |c| }{標籤的狀況描述} \\\hline
    LeftMoreThanRight  & 當左側的節點超過右側的節點數量時，進行改寫系統會使左側無法對應到右側的節點產生遺失的情形。若這些節點原先已有與其它非規則內節點連接，將會導致該連接資訊遺失，有機會造成任務圖破碎。 \\\hline
    EmptyLeft          & 左側為空將無法進行子圖搜索，因此左側節點必須至少一個節點。 \\\hline
    IsolatedNode       & 孤立的節點將會導致任務圖破碎。 \\\hline
    IsolatedConnection & 孤立的連接線無法正確表示其連接資訊，將無法正常進行改寫系統。 \\\hline
    ExactlyDuplicated  & 若左右規則同構將導致改寫系統陷入無限循環。 \\\hline
    MultipleRelations  & 兩兩節點間不可有超過一個的連接關係，不論是同向連接線或反向連接線皆會導致改寫系統無法正常運作。 \\\hline
    CyclicLink         & 任務圖的定義中，任務應嚴格遵守任務間之順序性，若有循環結構將會使玩家迂迴停滯。 \\\hline
    OrphanNode         & 若有圖形語法含有兩個以上的根結點，便無法正確定位出任務起點。 \\\hline
    OverflowedAnyNode  & 當右側規則使用 Any 節點時，其對應到左側索引值的節點亦必須為 Any 節點。反之，左側規則使用 Any 節點將不在此限。 \\\hline
  \end{tabular}
\end{table}

\subsection{產生任務圖}
\label{ssec:method-missiongrammars-graph}

根據 Joris Dormans~\cite{dormans2010adventures} 提出的方法並修改至符合我方實驗需求，歸納出演算法~\ref{alg:algorithm-missiongrammars-rewritesystem}。任務語法的改寫系統運行時以深度優先搜尋法 (Depth-first search) 遍歷整個任務圖，過程中遵循以下步驟順序。第一步驟，源節點會從任務規則集合中過濾出相符的規則，若有多項規則同時符合替換的條件時，系統會基於它們的關聯權重 (relative weight) 從複數個規則中依照採輪盤法 (roulette wheel selection) 選擇出一項任務規則稱之為匹配規則 (matched rule)，並從源節點進行與匹配規則的改寫替換，符合的條件為定義遍歷中的源節點作為新圖，而新圖存在一個子圖與匹配規則的左側之圖形語法同構，同構的參考基準為節點的符號種類，在確認子圖同構的同時，有關連的節點會標記與匹配規則一致的索引值。第二步驟，將任務圖含有索引值的節點，其相連的連接線移除。第三步驟，任務圖含有有索引值的節點取代成匹配規則右側的等價節點。第四步驟，將匹配規則右側中沒有與左側等價的節點添加至任務圖中。第五步驟，依照匹配規則右側的連接線，以相同方式放入任務圖中。最後一步驟，將任務圖中的索引值移除。

在~\ref{ssec:method-missiongrammars-rules} 小節提及，完整的任務圖必不包含任何的非終端節點，倘若經過多次疊代改寫仍有非終端節點存在，關卡設計師必須修改任務語法其規則，使之能夠完整轉換成全終端節點的任務圖，方可進入下一階段的空間轉換。

\begin{algorithm}[ht]
    \caption{RewriteSystem1 - 任務語法的改寫系統}
    \label{alg:algorithm-missiongrammars-rewritesystem}
    \begin{algorithmic}[1]
        \Require
            \Statex $root$ is current $pointer$ in the mission graph.
            \Statex $rules$ is a rule set of mission grammars.
            \Statex $seed$ is the random seed.
        \Ensure
            \If {$matchedRule$ is found from $root$}
                \State {matchedRule = FindMatchs(root)}
                \State {移除與 matchedRule 相符子圖的連接線}
                \State {將相符子圖的節點，依照對應索引值替換成 matchedRule 的規則右側}
                \State {將 matchedRule 剩餘的節點填充至任務圖中}
                \State {依照 matchedRule 的連接情況，移轉到任務圖中}
                \State {移除節點的索引值相關資訊}
            \EndIf
            \ForAll {$child$ such that $child\in children$ of $root$}:
                \State {RewriteSystem1($child$, $rules$, $seed$)}
            \EndFor \\
            \Return {$root$}
        \Statex
    \end{algorithmic}
\end{algorithm}


(備註，此處會補上 FindMatchs 在我方實驗環境中如何實現，目前還在構思要如何撰寫。)

% \begin{algorithm}
%     \caption{利用 VF Graph 進行子圖同構的搜尋}
%     \label{alg:algorithm-missiongrammars-rewritesystem-findmatchs}
%     \begin{algorithmic}
%         \RETURN 編輯中
%     \end{algorithmic}
% \end{algorithm}

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/final-mission-graph.png}
    \caption{最終輸出的任務圖} 
    \label{fig:final-mission-graph}
  \end{center}
\end{figure}

% Clean the page after this section.
\clearpage

\section{空間建構}
\label{sec:method-spacepieces}

Joris Dormans 於文獻中提到為二維空間的範例~\cite{dormans2010adventures}~\cite{dormans2012engineering}，我們的實驗環境以三維空間為主。在空間語法中將直接構築遊戲的基礎房型，但不設置怪物、寶箱或陷阱足以直接影響遊戲性的遊戲物件，如圖~\ref{fig:gameobject-list}。此外，我們希望空間中的遊戲物件能夠有意義的自動化配置，即在設計空間語法的流程中，忽略絕大部分的遊戲物件配置，直到~\ref{sec:method-segments} 節提出之方法達成。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/gameobject-list.png}
    \caption{影響遊戲性的遊戲物件，由左至右分別為敵方、寶箱與陷阱} 
    \label{fig:gameobject-list}
  \end{center}
\end{figure}

\subsection{基礎結構}
\label{ssec:method-spacepieces-basic}

我們對於空間語法做了修改以利實驗環境建置。圖~\ref{fig:spacepieces-structure} 所示，在一個關卡 (level) 中包含數個房間容器 (volumes)，每一房間由不定數量的房間塊 (chucks) 組成，且房間塊固定以 9x9x9 個長方體體素 (voxels) 所構成，每一體素的大小為 3x2x3。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/spacepieces-structure.png}
    \caption{房間容器的建構情形，可觀察其由體素單位所構築而成} 
    \label{fig:spacepieces-structure}
  \end{center}
\end{figure}

此外，每一個體素被分為九種方向，分別為正四方、斜四方與中心點。不同的裝飾物會依照其特性決定能夠放置的方位，如牆壁放置於正四方；牆壁柱放置於斜四方；地面或階梯則放置於中心點。在一個體素中，多個裝飾物是能夠同時並存的，例如在其放置地面、一道牆壁、兩道牆壁柱。在本次實驗環境中，我們將會使用圖~\ref{fig:decorations-with-directions} 中，「地面、階梯、牆壁、牆壁柱、門」共五種裝飾物進行房間容器的建置工作。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/decorations-with-directions.png}
    \caption{房間容器時所使用的五種裝飾物}
    \label{fig:decorations-with-directions}
  \end{center}
\end{figure}

\subsection{端點識別物}
\label{ssec:method-spacepieces-connections}

逐一設計出各式各樣的房間容器後，必須正確地將個空間相互連接。參考 Joris Dormans 的空間語法~\cite{dormans2012engineering}，我們為體素型的房間容器添加端點識別物 (connections)，而端點可再細分為入口 (entrance) 與出口 (exit)，依照遊戲設計師需求，能夠自行擴充出口的類型，可為複數個出口識別物。在一房間容器中，最多僅能擁有一個入口識別物，而出口識別物的數量不在此限，且二者之數量總和必大於零。倘若空間當中沒有一個以上入口識別物，便會從現有的出口識別物中隨機挑選一與入口識別物相同功能執行之。圖~\ref{fig:connections-in-volume} 中描述了端點識別物的使用情境，入口的箭頭朝向空間內部，而出口的箭頭會朝向空間外部。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/connections-in-volume.png}
    \caption{端點識別物的實際使用與串接情形} 
    \label{fig:connections-in-volume}
  \end{center}
\end{figure}

\subsection{房間容器類型}
\label{ssec:method-spacepieces-types}

延續第~\ref{sec:method-missiongrammars} 節任務語法所定義的任務終端節點，根據依照節點性質設計房型，區分出數項不同房型的空間規劃。

\subsubsection{入口、出口、魔王房}
\label{sssec:method-spacepieces-types-mainpath-i}

入口擁有一個入口與三個出口，為玩家重生的起始房間。出口擁有一個入口，為遊戲關卡結束的房間。魔王房擁有一個入口與一個出口，玩家會在此房間遭遇強大敵人。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/roomtype-mainpath-i.png}
    \caption{房間類型 - 由左至右為入口、出口與魔王房}
    \label{fig:roomtype-mainpath-i}
  \end{center}
\end{figure}

\subsubsection{通道}
\label{sssec:method-spacepieces-types-path}

通道共有四種，隨著端點數量有等同的出口數量，因沒有入口識別物，便能夠以任一出口作為入口，搭配房間容器旋轉能達到共計 11 種房型同構。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/roomtype-mainpath-ii.png}
    \caption{房間類型 - 由左至右為 I 型、L 型、T 型與 + 型通道}
    \label{fig:roomtype-mainpath-ii}
  \end{center}
\end{figure}

\subsubsection{石牆、秘密房、鎖、商店、寶藏房}
\label{sssec:method-spacepieces-types-special}

石牆擁有一個入口及一個出口，而出口的相同位置有石牆識別物。秘密房擁有一個入口，玩家能在該空間取得鑰匙識別物。鎖空間擁有一個入口及一個出口，在出口的相同位置有鎖識別物，玩家必須取得鑰匙方可通過。商店與寶藏房各擁有一個入口，玩家能夠在該房間觸發特殊事件。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/roomtype-special.png}
    \caption{房間類型 - 由左至右為石牆、秘密房、鎖、商店與寶藏房}
    \label{fig:roomtype-special}
  \end{center}
\end{figure}

\subsubsection{死路}
\label{sssec:method-spacepieces-types-wall}

在第~\ref{ssec:method-spacepieces-frommissiontospace} 小節中，為了要封閉剩餘的端點識別物所造成的空間開口，便需要無特殊功能的單一入口空間容器。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/roomtype-wall.png}
    \caption{房間類型 - 死路}
    \label{fig:roomtype-wall}
  \end{center}
\end{figure}

\subsection{從任務圖轉為遊戲空間}
\label{ssec:method-spacepieces-frommissiontospace}

Joris Dormans 提到任務圖與空間圖應當是非常近似，甚至是二者同構~\cite{dormans2010adventures}。本小節將解釋 Dungeon Generator 工具運行「將任務轉為空間的改寫系統」的流程，以及如何搭配任務圖的語法分析器。其一，藉由「建造方式表」能將任務圖轉換成有意義拓撲關係的遊戲空間；其二，利用「空間替換表」把前述遊戲空間不足之處補足。完成上述改寫系統進程後，便能夠輸出帶有任務邏輯的遊戲空間。演算法~\ref{alg:algorithm-mission-to-space-rewritesystem} 中，系統會遵循第~\ref{ssec:method-missiongrammars-graph} 小節產生的任務圖，以深度優先搜尋法遍歷任務圖，經過的源節點遍從建造方式表中挑選出一個房間容器，逐一將各個終端節點轉換為實際空間，接著透過建造方式表，將場面上剩餘的端點識別物依序替換成對應房間容器，以完成遊戲空間之建置。

\begin{algorithm}[ht]
    \caption{RewriteSystem2 - 將任務轉為空間的改寫系統}
    \label{alg:algorithm-mission-to-space-rewritesystem}
    \begin{algorithmic}[1]
        \Require
            \Statex $graph$ is current $MissionGraph$.
            \Statex $seed$ is the random seed.
        \Ensure
            \ForAll {$node$ such that $node\in graph$}:                             \Comment{Instrcution}
                \State {$volume$ = GetVolumeFromInstructionTable($node$, $seed$)}
                \State {$isSucceed$ = SetVolumeToSpace($volume$, $seed$)}           \Comment{return $true$ or $false$}
                \If {$isSucceed$ is $false$}
                    \Return {$false$}
                \EndIf
            \EndFor
            \ForAll {$marker$ such that $marker\in ConnectionsInGraph$}:            \Comment{Replacement}
                \State {$volume$ = GetVolumeFromReplacementTable($marker$, $seed$)}
                \State {$isSucceed$ = SetVolumeToSpace($volume$, $seed$)}           \Comment{return $true$ or $false$}
                \If {$isSucceed$ is $false$}
                    \Return {$false$}
                \EndIf
            \EndFor \\
            \Return {$true$}                                                        \Comment{Successfully generated a game space}
        \Statex
    \end{algorithmic}
\end{algorithm}

\subsubsection{建造方式}
\label{sssec:method-spacepieces-frommissiontospace-instruction}

為從已生成完畢的任務圖進而衍生出遊戲空間，在創建的房間容器會對應一任務符號表當中的終端符 (terminal symbols)，稱作為建造方式 (building instruction)。本小節會利用第~\ref{ssec:method-missiongrammars-alphabet} 小節的任務符號表，過濾出終端節點並逐一對應至第~\ref{ssec:method-spacepieces-types} 小節的房間容器，見圖~\ref{fig:mission-to-space-instruction}。每一個終端節點都必須對應一個以上的房間容器，房間容器不允許被重複使用在不同的終端節點上。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/mission-to-space-instruction.png}
    \caption{建造方式，任務終端節點與房間容器對應之範例} 
    \label{fig:mission-to-space-instruction}
  \end{center}
\end{figure}

基於建造方法的對應紀錄，給予一亂數種子能夠確保能夠對應到一固定空間。當終端節點對應到複數房間容器時，亂數種子將影響從多個房間容器之間的順序。若生成過程中，該房間容器擁有多個出口，亦是參照亂數種子決定調用出口生成之順序，見圖~\ref{fig:mission-to-space-instruction-result}。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/mission-to-space-instruction-result.png}
    \caption{已疊代生成的任務圖，不同亂數種子轉換為對應結果的遊戲空間} 
    \label{fig:mission-to-space-instruction-result}
  \end{center}
\end{figure}

\subsubsection{剩餘空間替換}
\label{sssec:method-spacepieces-frommissiontospace-replacement}

在圖~\ref{fig:mission-to-space-instruction-result} 可觀察到，經過建造方式的遊戲空間仍會遺留部分的端點識別物，為了將其延伸或予以封閉，本小節將進行替換 (replacement) 以達目的。第~\ref{ssec:method-spacepieces-connections} 小節，介紹端點識別物時，曾提及到遊戲設計師能夠自由擴充出口識別物的種類。在此為簡化範例，我們採用預設之單一出口識別物，而這項出口識別物將對應圖~\ref{fig:roomtype-wall} 的死路，若增加對應的選項進而創造出主線外的分支結構，見圖~\ref{fig:mission-to-space-replacement-result}。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/mission-to-space-replacement-result.png}
    \caption{經過剩餘空間替換後的完整遊戲空間} 
    \label{fig:mission-to-space-replacement-result}
  \end{center}
\end{figure}

% Clean the page after this section.
\clearpage

\section{地圖片段}
\label{sec:method-segments}

為了將第~\ref{ssec:relatedworks-proceduralgamepatterns} 小節提及的程序化遊戲物件擺放技術付諸實現，構築出遊戲內部的複雜系統，讓玩家體驗到突現型 (emergence) 的遊玩機制，我們將延續上一節的遊戲關卡結構，參考 Antonios Liapis 提出的地圖片段演化方法~\cite{liapis2017multi}，進行改良以合適我方實驗環境。

房間容器視為單一染色體 (chromosome) 之個體 (individual)；房間容器中能夠放置遊戲物件的各點座標視為基因 (genes)，而基因的類型有空磚、怪物磚、寶箱磚與陷阱磚等；同一個房間容器會擁有多種不同遊戲物件配置情況的染色體，這些染色體的集合便是族群 (population)。第一步驟，產生初始父母代族群時，讓全部的基因先預設為空磚，並使各染色體先行隨機突變；第二步驟，透過適應性函數計算各染色體的適應值 (fitnesses)，完整的適應性函數在~\ref{ssec:method-segments-fitnesses} 小節中說明；第三步驟將會從族群中挑選最優異的兩個父母染色體，高機率進行交配，若無進行交配將會將子代沿用父母代的基因；第四步驟有低機率讓衍生的子代進行突變；第五步驟以新的衍生子代取代舊有的父母代族群；第六步驟會檢查是否達到終止條件，若尚未滿足終止條件，便會回到第二步驟，直到輸出最適解。前述之交配、突變事件的機率與其方法屬於實驗變因，將在第~\ref{cha:experiment} 章進行定義與相關釋義。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/under_construction.png}
    \caption{地圖片段採取基因演算法之演化流程} 
    \label{fig:segments-with-ga}
  \end{center}
\end{figure}

\subsection{演化之適應性函數}
\label{ssec:method-segments-fitnesses} 

動作冒險遊戲 (A-AVG)、動作角色扮演遊戲 (A-RPG) 等類型遊戲，多可見一些制式化遊戲物件的搭配組合，我們嘗試汲取出多項遊玩特徵並參數化公式，作為評估關卡品質的指標之一。在前處理時，圖~\ref{fig:decorations-with-directions} 中顯示的地面、階梯裝飾物屬於可以通行的瓦磚單位（請參考圖~\ref{fig:decorations-with-directions} 左一與左二），使用 A-Star 搜尋演算法建立行走空間，並搜索入口至多個出口的最短路徑，凡經過的座標稱作為空間動線 ($MP$) 之一，並將其權重值 ($mp$) 增加 1，空間動線為多項指標關鍵性的參考依據。倘若遇到無法計算最短路徑的情形，空間動線將為空值。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/fitnesses-mainpath.png}
    \caption{動線於房間容器的計算方式，黃色處行經 2 次、紅色處行經 1 次}
    \label{fig:fitnesses-mainpath}
  \end{center}
\end{figure}

\subsubsection{守衛點 (Guard)}
\label{sssec:method-segments-fitnesses-guard}

為體現出敵人會保衛寶箱 ($T$) 與出口 ($E$) 的現象，計算敵方單位 ($E_{i}$) 與關鍵性較高遊戲物件 ($O_{j}$) 之間的距離，倘若距離愈近則帶來的影響力愈大。

\begin{equation}
    f_{grd}=\frac{1}{N \times M} \sum_{i=1}^{N} \sum_{j=1}^{M} \frac{1}{dist\big(E_{i}, O_{j}\big)}, O_{j} \in \{ Treasure, Exit \}
\end{equation}

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/fitnesses-guard-gameplay.png}
    \caption{守衛點指標的遊戲體現情形}
    \label{fig:fitnesses-guard-gameplay}
  \end{center}
\end{figure}

\subsubsection{阻攔點 (Block)}
\label{sssec:method-segments-fitnesses-block}

方程式~\ref{eq:fitnesses-block} 為阻攔點的適應性函數。敵人會專注於阻擋玩家繼續前進，迫使玩家與其發生衝突。$MP$ 為加總所有空間動線權重 $mp_{i}$；$E$ 為加總所有敵人於空間之動線權重 ($e_{j}$)，倘敵人並未落在動線上，權重則為 0。為了達到隨著動線上的敵人愈多，對此適應性函數的影響力愈低，則取以 $MP$ 為底 $E$ 的對數。圖~\ref{fig:fitnesses-block-gameplay} 為阻攔點指標的實際遊玩情形，灰色區塊為系統計算出的空間動線的瓦磚，敵人會被設置於動線之上阻擋玩家前行。

\begin{equation}
    \label{eq:fitnesses-block}
    f_{blk} = \log _{MP} E, MP = \sum_{i=1}^{M} mp_{i}, E = \sum_{j=1}^{N} e_{j}
\end{equation}

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/fitnesses-block-gameplay.png}
    \caption{阻攔點指標的遊戲體現情形}
    \label{fig:fitnesses-block-gameplay}
  \end{center}
\end{figure}

\subsubsection{攔截點 (Intercept)}
\label{sssec:method-segments-fitnesses-intercept}

與阻攔點近似，但敵人會被配置於動線附近非動線上，以快速追擊玩家為目的。各敵人 ($E_{i}$) 越接近空間動線各點 ($MP_{j}$) 時影響愈大，且動線權重 ($mp_{j}$) 亦會影響加權程度。

\begin{equation}
    f_{itc} = \frac{1}{N \times M} \sum_{i=1}^{N} \sum_{j=1}^{M} \Big( \frac{1}{dist(E_{i}, MP_{j})} \times mp_{j} \Big), 
    E_{i} \neq MP_{j}
\end{equation}

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/fitnesses-intercept-gameplay.png}
    \caption{攔截點指標的遊戲體現情形}
    \label{fig:fitnesses-intercept-gameplay}
  \end{center}
\end{figure}

\subsubsection{巡邏點 (Patrol)}
\label{sssec:method-segments-fitnesses-patrol}

確保各敵人擁有足夠的空間能夠進行移動。將計算敵人 ($E_{i}$) 與指定半徑 ($r$) 內的座標數量 ($P_j$) 總值，當中並不包含不可通行的牆壁等類型。於本次實驗中，我們將採用 $R=3$ 作為實驗範例，該數值可由遊戲設計師決定。

\begin{equation}
    % The old one: f_{ptl}=\sum_{i=1}^{N} \sum_{j=1}^{M} count\big(E_{i}, P_{j}\big), dist\big(E_{i}, P_{j}\big) \leq r, P_{j} \notin \{ wall \}
    f_{ptl} = \sum_{i=1}^{N} \Big( d_{i} \times \sum_{j=1}^{M} count\big(E_{i}, P_{j}\big) \Big), 
    d_{i} = \begin{cases}
                \frac{1}{2^{i}},   & \mbox{if } i \neq N \\
                \frac{1}{2^{i-1}}, & \mbox{if } i = N
            \end{cases}
\end{equation}
\begin{gather*}
    dist\big(E_{i}, P_{j}\big) \leq r,  P_{j} \notin wall
\end{gather*}

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/fitnesses-patrol-gameplay.png}
    \caption{巡邏點指標的遊戲體現情形}
    \label{fig:fitnesses-patrol-gameplay}
  \end{center}
\end{figure}

\subsubsection{至高點 (Dominated)}
\label{sssec:method-segments-fitnesses-dominated}

當玩家可能所在動線上之位置 ($MP_{j}$) 與敵人的位置 ($E_{i}$) 具有高低差時，敵人便適合採取遠程攻擊；為了提供玩家思考對付遠程敵人的緩衝時間，將敵人配置於動線末端附近是較好的選擇，$j$ 隨著動線的順序演進，影響程度逐漸增幅。

\begin{equation}
f_{dom}=\sum_{i=1}^{N} \sum_{j=1}^{M} \Big( \frac{1}{dist\big(E_{i}, MP_{j}\big)} \times mp_{j} \times j \times high(E_{i}, MP_{j}) \Big)
\end{equation}

\subsubsection{支援點 (Support)}
\label{sssec:method-segments-fitnesses-support}

敵人 ($E_{i}$, $E_{j}$) 之間擁有一定程度的護援關係，當敵人彼此的距離愈低其影響程度越大，同時該敵人 ($E_{i}$) 必須遠離動線 ($MP_{k}$)。

\begin{equation}
f_{sup}=\frac{1}{N} \sum_{i=1}^{N} \bigg( \frac{1}{N} \sum_{\substack{j=1 \\ j \neq i}}^{N} \frac{1}{dist(E_{i}, E_{j})} + \frac{1}{M} \sum_{k=1}^{M} \frac{1}{dist(E_{i}, MP_{k})} \bigg)
\end{equation}

% \subsubsection{死角點 (Neglected)}
% \label{sssec:method-segments-fitnesses-neglected}

% 由於房與房之間的牆壁阻隔，使得敵人能夠埋伏於入口附近之死角處，出奇不意地對玩家展開攻擊。為了體現出這種現象，我們將敵人 ($E_{i}$) 與空間動線上各點 ($MP_{i}$)，兩端點連線之對角線所構成的立方體，立方體所涵蓋各座標點 ($N_{j}$) 至該對角線的距離為 $d_{k}$，隨著距離增加影響程度會衰減；$vis_{k}$ 為該點的可視情形，若有不可視的座標存在便會提高適應值。隨著動線的順序演進，影響程度逐漸衰減。

% \begin{equation}
%     Under construction
% \end{equation}

\subsection{制衡取向的適應性函數}
\label{ssec:method-segments-balancefitness}

於~\ref{ssec:method-segments-fitnesses} 小節所提及的適應性函數中，多數的函數有著一項共通點，便是隨著符合遊玩特徵的物件數量與適應性得分呈現顯著正相關，隨著演化代數的提升至終導致房間容器充斥著大量的遊戲物件。然而這樣的遊玩體驗在絕大多數都是不可行的，因此需要針對現有適應性函數所衍生出的特性，設計抑制其得分隨著數量級的成長。

方程式~\ref{eq:fitnesses-density} 控制該房型出現的遊戲物件總數。房間容器的物件總數上限為 $M$、下限為 $N$，若遊戲物件總數為 $O$ 屬於數量範圍內可得 1 分，反之得 0 分，本適應性函數的權重固定為 1。

\begin{equation}
    \label{eq:fitnesses-density}
    f_{dst} = \begin{cases}
                  1, & \mbox{if } N \leq O \leq M \\
                  0, & \mbox{if } O<N \text{ or } O>M
              \end{cases}
\end{equation}

\subsection{負數權重的適應性函數}
\label{ssec:method-segments-minusscores}

在~\ref{sssec:method-segments-fitnesses-guard} 守衛點指標的設計中，當權重為正數時能夠體現出「需要被保護的物件，其周圍分配敵方單位進行守衛」的遊玩特徵，且在多個物件的情形下儘可能平均分配敵方單位；反之，負數權重便會體現出「數量愈不平均的守衛情形」。緣故為設計守衛點指標時，並無針對寶箱的數量進行控管而導致。

\subsection{多項適應性函數合併}
\label{ssec:method-segments-multiobjectives}

在設計適應性函數初期，為求多個適應性函數相互牽制，進而求得限制條件的最佳解。而初期函數會力求場上所有的敵人必須盡可能符合各項指標，舉例來說，在某一房間容器的設定中，我們將守衛點、阻攔點的權重調整至 1，其餘指標將不採計得分即不調整權重，倘若場面上存在著敵人 A 與 敵人 B，他們會同時被設置在動線上且一定距離內會有作為守護對象的寶箱物件。但對於遊戲設計師在某些情形下，敵人 A 與敵人 B 僅需要分別符合守衛點、阻攔點指標，才是理想中的遊玩特徵。因此，我們定義「首次出現相關遊玩特徵的得分幅度最顯著」，並依照出現數量逐漸下降成長幅度且逼近於 1，呈現近似於對數函數圖形的曲線，因此上述兩種情形都有機會成為演化過程中的最適解。取代原先的線性成長關係，進行數值的標準化，強制將值域規範至 $[-1, 1]$ 以求最後適應性函數加權總分時，不偏袒任何適應性函數以達到公平基準，並於第 ~\ref{sec:experiment-normalized} 節進行相關驗證。

方程式~\ref{eq:fitnesses-all} 中定義房間容器（個體）的品質，採計共 $M$ 種適應性函數，第 $i$ 項適應性得分為 $f_{i}$ 並經過標準化 $Normalized(f_{i}) = [-1, 1]$，依照各函數得分與其權重值 $w_{i} = [-1, 1]$ 加權後加總得到 $f_{all}$。而標準化由底數 $f_{i}\cdot max$（該世代最高得分）與真數 $f_{i} - 1$（個體得分）之對數函數所得。

\begin{equation}
    \label{eq:fitnesses-all}
    f_{all} = \sum_{i=1}^{M} (Normalized(f_{i}) \times w_{i})
\end{equation}
\begin{gather*}
    Normalized(f_{i}) = \log _{f_{i}\cdot max} (f_{i} - 1)
\end{gather*}

\subsection{套用物件演化機制的房間容器}
\label{ssec:method-segments-appliedonvolumes}

綜合上述小節，不同房間容器類型會有對應的戰略配置。承接~\ref{ssec:method-spacepieces-types} 小節所介紹的房間容器外，在本小節追加了戰鬥通道的房間容器，與前章節提及之通道不同處，在戰鬥通道中玩家恐會遭遇敵方單位。戰鬥通道的格局是經過特殊設計的，敵方單位能夠依照不同房型格局進行對應的戰鬥策略，見圖~\ref{fig:roomtype-mainpath-extend}。因此依照房間容器類型設置不同的適應性函數權重，逐一定義各自的適應性函數權重值。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/under_construction.png}
    \caption{房間類型 - 戰鬥通道}
    \label{fig:roomtype-mainpath-extend}
  \end{center}
\end{figure}

\subsubsection{寶藏房}
\label{sssec:method-segments-appliedonvolumes-none}

此段僅為介紹，編輯中。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/under_construction.png}
    \caption{寶藏房的遊戲物件佈局演化示意} 
    \label{fig:applied-ga-on-volume-battlepath-ii}
  \end{center}
\end{figure}

\subsubsection{戰鬥通道 - 鎮守要道}
\label{sssec:method-segments-appliedonvolumes-battlepath-i}

此段僅為介紹，編輯中。

守衛點權重 1、

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/under_construction.png}
    \caption{鎮守要道情境的遊戲物件佈局演化示意} 
    \label{fig:applied-ga-on-volume-battlepath-ii}
  \end{center}
\end{figure}

\subsubsection{戰鬥通道 - 狹路驅逐}
\label{sssec:method-segments-appliedonvolumes-battlepath-ii}

此段僅為介紹，編輯中。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/under_construction.png}
    \caption{狹路驅逐情境的遊戲物件佈局演化示意} 
    \label{fig:applied-ga-on-volume-battlepath-ii}
  \end{center}
\end{figure}

\subsubsection{其餘房間容器}
\label{sssec:method-segments-appliedonvolumes-others}

其餘未被定義的房型，像是入口、出口、一般通道 ... 等，因設計需求將不配置任何遊戲物件，即不參與相關演化流程。

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{figures/under_construction.png}
    \caption{將房間容器作為胚胎，進行空間內遊戲物件的演化生成} 
    \label{fig:applied-ga-on-volume}
  \end{center}
\end{figure}
